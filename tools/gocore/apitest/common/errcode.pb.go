// Code generated by protoc-gen-go-gin. DO NOT EDIT.
// versions:
// - protoc-gen-go-gin v1.0.0
// - protoc            v4.24.2
// source: apitest/errcode.proto

package common

import (
	errors "errors"
	ecode "github.com/sunmi-OS/gocore/v2/api/ecode"
)

const (
	ERR_COMMON_UNKNOWN           = 0
	ERR_BAD_REQUEST              = 400
	ERR_NOT_AUTHENTICATED        = 401
	ERR_FORBIDDEN                = 403
	ERR_NOT_FOUND                = 404
	ERR_METHOD_NOT_ALLOWED       = 405
	ERR_REQUEST_TIMEOUT          = 408
	ERR_CONFLICT                 = 409
	ERR_GONE                     = 410
	ERR_REQUEST_ENTITY_TOO_LARGE = 413
	ERR_RANGE_NOT_SATISFIABLE    = 416
	ERR_TOO_MANY_REQUESTS        = 429
	ERR_INTERNAL_SERVER_ERROR    = 500
	ERR_NOT_IMPLEMENTED          = 501
	ERR_BAD_GATEWAY              = 502
	ERR_SERVICE_UNAVAILABLE      = 503
	ERR_GATEWAY_TIMEOUT          = 504
)

var (
	ErrMap = map[int]string{
		ERR_COMMON_UNKNOWN:           "common unknown",
		ERR_BAD_REQUEST:              "Bad request",
		ERR_NOT_AUTHENTICATED:        "Not authorized",
		ERR_FORBIDDEN:                "Forbidden",
		ERR_NOT_FOUND:                "Not found",
		ERR_METHOD_NOT_ALLOWED:       "Method not allowed",
		ERR_REQUEST_TIMEOUT:          "Request timeout",
		ERR_CONFLICT:                 "Conflict",
		ERR_GONE:                     "Resource gone",
		ERR_REQUEST_ENTITY_TOO_LARGE: "Request entity too large",
		ERR_RANGE_NOT_SATISFIABLE:    "Range not satisfiable",
		ERR_TOO_MANY_REQUESTS:        "Too many requests",
		ERR_INTERNAL_SERVER_ERROR:    "Internal server error",
		ERR_NOT_IMPLEMENTED:          "Server not implemented this function",
		ERR_BAD_GATEWAY:              "Bad gateway",
		ERR_SERVICE_UNAVAILABLE:      "Service unavailable",
		ERR_GATEWAY_TIMEOUT:          "Gateway timeout",
	}
)

func makeNewErr(code int, msg ...string) *ecode.ErrorV2 {
	msgStr := ErrMap[code]
	if len(msg) > 0 {
		msgStr = msg[0]
	}
	return ecode.NewV2(code, msgStr)
}

// code: 0 msg: "common unknown"
func ErrCommonUnknown(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_COMMON_UNKNOWN, msg...)
}

// code: 400 msg: "Bad request"
func ErrBadRequest(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_BAD_REQUEST, msg...)
}

// code: 401 msg: "Not authorized"
func ErrNotAuthenticated(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NOT_AUTHENTICATED, msg...)
}

// code: 403 msg: "Forbidden"
func ErrForbidden(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_FORBIDDEN, msg...)
}

// code: 404 msg: "Not found"
func ErrNotFound(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NOT_FOUND, msg...)
}

// code: 405 msg: "Method not allowed"
func ErrMethodNotAllowed(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_METHOD_NOT_ALLOWED, msg...)
}

// code: 408 msg: "Request timeout"
func ErrRequestTimeout(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_REQUEST_TIMEOUT, msg...)
}

// code: 409 msg: "Conflict"
func ErrConflict(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_CONFLICT, msg...)
}

// code: 410 msg: "Resource gone"
func ErrGone(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_GONE, msg...)
}

// code: 413 msg: "Request entity too large"
func ErrRequestEntityTooLarge(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_REQUEST_ENTITY_TOO_LARGE, msg...)
}

// code: 416 msg: "Range not satisfiable"
func ErrRangeNotSatisfiable(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_RANGE_NOT_SATISFIABLE, msg...)
}

// code: 429 msg: "Too many requests"
func ErrTooManyRequests(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_TOO_MANY_REQUESTS, msg...)
}

// code: 500 msg: "Internal server error"
func ErrInternalServerError(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_INTERNAL_SERVER_ERROR, msg...)
}

// code: 501 msg: "Server not implemented this function"
func ErrNotImplemented(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NOT_IMPLEMENTED, msg...)
}

// code: 502 msg: "Bad gateway"
func ErrBadGateway(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_BAD_GATEWAY, msg...)
}

// code: 503 msg: "Service unavailable"
func ErrServiceUnavailable(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_SERVICE_UNAVAILABLE, msg...)
}

// code: 504 msg: "Gateway timeout"
func ErrGatewayTimeout(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_GATEWAY_TIMEOUT, msg...)
}

func IsErrCommonUnknown(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_COMMON_UNKNOWN
	}
	return false
}

func IsErrCommonUnknownDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_COMMON_UNKNOWN && se.Message() == ErrMap[ERR_COMMON_UNKNOWN]
	}
	return false
}

func IsErrBadRequest(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_REQUEST
	}
	return false
}

func IsErrBadRequestDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_REQUEST && se.Message() == ErrMap[ERR_BAD_REQUEST]
	}
	return false
}

func IsErrNotAuthenticated(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_AUTHENTICATED
	}
	return false
}

func IsErrNotAuthenticatedDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_AUTHENTICATED && se.Message() == ErrMap[ERR_NOT_AUTHENTICATED]
	}
	return false
}

func IsErrForbidden(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_FORBIDDEN
	}
	return false
}

func IsErrForbiddenDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_FORBIDDEN && se.Message() == ErrMap[ERR_FORBIDDEN]
	}
	return false
}

func IsErrNotFound(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_FOUND
	}
	return false
}

func IsErrNotFoundDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_FOUND && se.Message() == ErrMap[ERR_NOT_FOUND]
	}
	return false
}

func IsErrMethodNotAllowed(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_METHOD_NOT_ALLOWED
	}
	return false
}

func IsErrMethodNotAllowedDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_METHOD_NOT_ALLOWED && se.Message() == ErrMap[ERR_METHOD_NOT_ALLOWED]
	}
	return false
}

func IsErrRequestTimeout(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_TIMEOUT
	}
	return false
}

func IsErrRequestTimeoutDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_TIMEOUT && se.Message() == ErrMap[ERR_REQUEST_TIMEOUT]
	}
	return false
}

func IsErrConflict(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_CONFLICT
	}
	return false
}

func IsErrConflictDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_CONFLICT && se.Message() == ErrMap[ERR_CONFLICT]
	}
	return false
}

func IsErrGone(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GONE
	}
	return false
}

func IsErrGoneDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GONE && se.Message() == ErrMap[ERR_GONE]
	}
	return false
}

func IsErrRequestEntityTooLarge(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_ENTITY_TOO_LARGE
	}
	return false
}

func IsErrRequestEntityTooLargeDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_ENTITY_TOO_LARGE && se.Message() == ErrMap[ERR_REQUEST_ENTITY_TOO_LARGE]
	}
	return false
}

func IsErrRangeNotSatisfiable(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_RANGE_NOT_SATISFIABLE
	}
	return false
}

func IsErrRangeNotSatisfiableDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_RANGE_NOT_SATISFIABLE && se.Message() == ErrMap[ERR_RANGE_NOT_SATISFIABLE]
	}
	return false
}

func IsErrTooManyRequests(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_TOO_MANY_REQUESTS
	}
	return false
}

func IsErrTooManyRequestsDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_TOO_MANY_REQUESTS && se.Message() == ErrMap[ERR_TOO_MANY_REQUESTS]
	}
	return false
}

func IsErrInternalServerError(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_INTERNAL_SERVER_ERROR
	}
	return false
}

func IsErrInternalServerErrorDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_INTERNAL_SERVER_ERROR && se.Message() == ErrMap[ERR_INTERNAL_SERVER_ERROR]
	}
	return false
}

func IsErrNotImplemented(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_IMPLEMENTED
	}
	return false
}

func IsErrNotImplementedDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_IMPLEMENTED && se.Message() == ErrMap[ERR_NOT_IMPLEMENTED]
	}
	return false
}

func IsErrBadGateway(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_GATEWAY
	}
	return false
}

func IsErrBadGatewayDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_GATEWAY && se.Message() == ErrMap[ERR_BAD_GATEWAY]
	}
	return false
}

func IsErrServiceUnavailable(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_SERVICE_UNAVAILABLE
	}
	return false
}

func IsErrServiceUnavailableDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_SERVICE_UNAVAILABLE && se.Message() == ErrMap[ERR_SERVICE_UNAVAILABLE]
	}
	return false
}

func IsErrGatewayTimeout(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GATEWAY_TIMEOUT
	}
	return false
}

func IsErrGatewayTimeoutDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GATEWAY_TIMEOUT && se.Message() == ErrMap[ERR_GATEWAY_TIMEOUT]
	}
	return false
}
